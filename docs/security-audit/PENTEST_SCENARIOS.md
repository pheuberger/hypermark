# Penetration Testing Scenarios

This document provides detailed penetration testing scenarios for security auditors assessing the Hypermark Nostr sync implementation.

## Table of Contents

1. [Testing Environment Setup](#testing-environment-setup)
2. [Cryptographic Attack Scenarios](#cryptographic-attack-scenarios)
3. [Protocol Attack Scenarios](#protocol-attack-scenarios)
4. [Network Attack Scenarios](#network-attack-scenarios)
5. [Input Fuzzing Scenarios](#input-fuzzing-scenarios)
6. [Authentication Bypass Scenarios](#authentication-bypass-scenarios)
7. [Data Exfiltration Scenarios](#data-exfiltration-scenarios)

---

## Testing Environment Setup

### Prerequisites
- Node.js 18+ with development dependencies
- Access to Hypermark source code
- WebSocket debugging tools (e.g., Wireshark, Chrome DevTools)
- Local Nostr relay (e.g., nostr-rs-relay)
- Cryptographic testing tools

### Local Relay Setup
```bash
# Run local Nostr relay for testing
docker run -p 7777:7777 scsibug/nostr-rs-relay

# Configure Hypermark to use local relay
# Add to relay list: ws://localhost:7777
```

### Intercepting Proxy Setup
```bash
# For MITM testing, use mitmproxy or similar
mitmproxy --mode upstream:http://localhost:8080 --ssl-insecure
```

---

## Cryptographic Attack Scenarios

### CRYPTO-01: Key Derivation Oracle Attack

**Objective:** Determine if key derivation can be used as an oracle to leak information.

**Scenario:**
1. Observe timing differences in `deriveNostrSeed()` for different LEK values
2. Measure memory allocation patterns during derivation
3. Look for error message differences that leak key information

**Test Steps:**
```javascript
// Time derivation for different LEK values
const timings = [];
for (let i = 0; i < 1000; i++) {
  const lek = await generateLEK();
  const start = performance.now();
  await deriveNostrSeed(lek);
  timings.push(performance.now() - start);
}
// Analyze timing distribution for anomalies
```

**Expected Result:** Constant-time derivation with no information leakage.

**Findings Template:**
- Timing variation: ___ms
- Memory patterns: ___
- Error differences: ___

---

### CRYPTO-02: IV Reuse Detection

**Objective:** Verify IV is never reused across encryptions.

**Scenario:**
1. Encrypt same plaintext 10,000 times
2. Collect all IVs
3. Check for any duplicates (collision)

**Test Steps:**
```javascript
const ivSet = new Set();
const key = await generateLEK();
const plaintext = new TextEncoder().encode("test data");

for (let i = 0; i < 10000; i++) {
  const { iv } = await encryptData(key, plaintext);
  const ivHex = Array.from(iv).map(b => b.toString(16)).join('');
  if (ivSet.has(ivHex)) {
    console.error(`IV COLLISION at iteration ${i}!`);
  }
  ivSet.add(ivHex);
}
```

**Expected Result:** No IV collisions (probability < 2^-64 for 10K samples).

---

### CRYPTO-03: Weak Key Detection

**Objective:** Verify derived keys have sufficient entropy.

**Scenario:**
1. Generate 1000 Nostr keypairs from different LEKs
2. Analyze key distribution for patterns
3. Check for weak keys (small values, patterns)

**Test Steps:**
```javascript
const keys = [];
for (let i = 0; i < 1000; i++) {
  const lek = await generateLEK();
  const keypair = await deriveNostrKeypair(lek);
  keys.push(keypair.privateKeyHex);
}
// Statistical analysis:
// - Check first byte distribution
// - Check for repeated patterns
// - Verify uniform distribution
```

**Expected Result:** Keys uniformly distributed across valid secp256k1 range.

---

### CRYPTO-04: Signature Forgery Attempt

**Objective:** Verify signatures cannot be forged or malleated.

**Scenario:**
1. Capture valid signed event
2. Attempt to modify event while keeping signature valid
3. Attempt to create new event with same signature

**Test Steps:**
```javascript
// Get valid signed event
const event = await createSignedNostrEvent({
  kind: 30053,
  content: "test",
  tags: [["d", "test-id"], ["app", "hypermark"]]
}, keypair);

// Attempt 1: Modify content, keep signature
const tamperedEvent1 = { ...event, content: "tampered" };
const valid1 = await verifyNostrEventSignature(tamperedEvent1);
console.assert(!valid1, "Content tamper not detected!");

// Attempt 2: Modify timestamp, keep signature
const tamperedEvent2 = { ...event, created_at: event.created_at + 1 };
const valid2 = await verifyNostrEventSignature(tamperedEvent2);
console.assert(!valid2, "Timestamp tamper not detected!");

// Attempt 3: Use signature on different event
const newEvent = await computeEventId({
  pubkey: event.pubkey,
  created_at: Date.now(),
  kind: 30053,
  tags: event.tags,
  content: "different"
});
const stolen = { ...newEvent, sig: event.sig };
const valid3 = await verifyNostrEventSignature(stolen);
console.assert(!valid3, "Signature reuse not detected!");
```

**Expected Result:** All forgery attempts must fail.

---

## Protocol Attack Scenarios

### PROTO-01: Event Replay Attack

**Objective:** Verify old events cannot be replayed to revert state.

**Scenario:**
1. Device A publishes bookmark update at T1
2. Device A publishes new update at T2
3. Attacker replays T1 event
4. Verify T1 event is rejected or doesn't overwrite T2

**Test Steps:**
```javascript
// Simulate scenario with timestamps
const event1 = createEvent({ created_at: 1700000000 }); // T1
const event2 = createEvent({ created_at: 1700000100 }); // T2 (newer)

// Process event2 first (out of order arrival)
await processEvent(event2);

// Replay event1 (older)
await processEvent(event1);

// Verify latest state is from event2
const state = getBookmarkState();
console.assert(state.updatedAt === 1700000100, "Replay attack succeeded!");
```

**Expected Result:** Older events do not overwrite newer state.

---

### PROTO-02: Pubkey Impersonation

**Objective:** Verify attacker cannot impersonate user's pubkey.

**Scenario:**
1. Attacker creates event with victim's pubkey
2. Attacker signs with their own private key
3. Verify event is rejected

**Test Steps:**
```javascript
// Attacker's keypair
const attackerKeypair = await deriveNostrKeypair(attackerLek);

// Create event claiming to be from victim
const maliciousEvent = {
  pubkey: victimPubkey, // Victim's pubkey
  created_at: Math.floor(Date.now() / 1000),
  kind: 30053,
  tags: [["d", "victim-bookmark"], ["app", "hypermark"]],
  content: "attacker-controlled"
};

// Sign with attacker's key
const signedMalicious = await signNostrEvent(maliciousEvent, attackerKeypair.privateKeyBytes);

// Verify signature fails (signed with wrong key)
const valid = await verifyNostrEventSignature(signedMalicious);
console.assert(!valid, "Impersonation not detected!");
```

**Expected Result:** Signature verification fails for mismatched pubkey/key.

---

### PROTO-03: Delete Event Authorization

**Objective:** Verify only event owner can delete events.

**Scenario:**
1. User A creates bookmark
2. User B attempts to delete User A's bookmark
3. Verify deletion is rejected

**Test Steps:**
```javascript
// User A creates bookmark
const userAEvent = await publishBookmark(userAKeypair, "bookmark-123");

// User B creates delete event targeting User A's bookmark
const deleteEvent = {
  pubkey: getXOnlyPubkey(userBKeypair.publicKeyBytes),
  kind: 5, // Delete
  tags: [["a", `30053:${userAPubkey}:bookmark-123`]],
  content: ""
};
const signedDelete = await signNostrEvent(deleteEvent, userBKeypair.privateKeyBytes);

// Process delete event
await processEvent(signedDelete);

// Verify User A's bookmark still exists
const bookmark = getBookmark("bookmark-123");
console.assert(bookmark !== null, "Unauthorized deletion succeeded!");
```

**Expected Result:** Delete events only work for same pubkey.

---

### PROTO-04: Kind Confusion Attack

**Objective:** Verify event kind validation prevents type confusion.

**Scenario:**
1. Create event with kind 1 (text note) but bookmark-like content
2. Verify it's not processed as bookmark
3. Create event with kind 30053 but delete-like tags
4. Verify correct handling

**Test Steps:**
```javascript
// Text note masquerading as bookmark
const fakeBookmark = {
  kind: 1, // Text note, not 30053
  tags: [["d", "fake-id"], ["app", "hypermark"]],
  content: "encrypted-looking-content"
};

// Validate as Hypermark event
const result = await validateNostrEvent(fakeBookmark, { isHypermarkEvent: true });
console.assert(!result.valid, "Wrong kind accepted as bookmark!");
```

**Expected Result:** Kind validation rejects mismatched event types.

---

## Network Attack Scenarios

### NET-01: MITM During Pairing

**Objective:** Verify MITM cannot intercept LEK during pairing.

**Scenario:**
1. Set up MITM between two devices during pairing
2. Intercept signaling messages
3. Attempt to extract LEK or inject malicious device

**Test Steps:**
1. Configure MITM proxy for WebSocket traffic
2. Initiate pairing on Device A
3. Intercept QR code data
4. Attempt to use QR data to pair attacker device
5. Verify verification code mismatch detection

**Manual Testing:**
- Capture: WebSocket signaling messages
- Analyze: Encrypted vs plaintext data
- Attempt: Replay captured messages
- Verify: Out-of-band verification fails

**Expected Result:** Verification code prevents MITM.

---

### NET-02: Malicious Relay Injection

**Objective:** Verify malicious relay cannot inject fake events.

**Scenario:**
1. Set up malicious local relay
2. Configure Hypermark to connect to malicious relay
3. Inject events with valid structure but invalid signatures
4. Verify events are rejected

**Test Steps:**
```javascript
// Malicious relay sends fake event
const fakeEvent = {
  id: generateRandomHex(64),
  pubkey: victimPubkey,
  created_at: Math.floor(Date.now() / 1000),
  kind: 30053,
  tags: [["d", "fake"], ["app", "hypermark"]],
  content: "attacker-content",
  sig: generateRandomHex(128) // Random invalid signature
};

// Relay sends: ["EVENT", "sub-id", fakeEvent]
// Client should reject after signature verification
```

**Expected Result:** All events validated before processing.

---

### NET-03: Relay Denial of Service

**Objective:** Verify client handles relay misbehavior gracefully.

**Scenario:**
1. Relay sends oversized events
2. Relay sends malformed JSON
3. Relay never responds to requests
4. Relay sends events at high rate

**Test Steps:**
```javascript
// Scenario 1: Oversized event
const hugeEvent = createEvent({ content: "x".repeat(1000000) });
// Client should reject early

// Scenario 2: Malformed JSON
relay.send("not valid json{{{");
// Client should handle parse error

// Scenario 3: Flood of events
for (let i = 0; i < 10000; i++) {
  relay.send(["EVENT", "sub", createRandomEvent()]);
}
// Client should rate limit or handle gracefully
```

**Expected Result:** Client remains responsive under adversarial conditions.

---

### NET-04: Relay Information Leakage

**Objective:** Assess what information relays can learn.

**Scenario:**
1. Monitor all traffic to relay
2. Analyze metadata visible to relay
3. Document privacy implications

**Analysis Points:**
- IP address correlation
- Event timing patterns
- Event size analysis
- Pubkey activity patterns
- d-tag (bookmark ID) visibility

**Expected Result:** Document metadata leakage (accepted for MVP).

---

## Input Fuzzing Scenarios

### FUZZ-01: Event Structure Fuzzing

**Objective:** Find crashes or unexpected behavior with malformed events.

**Fuzzing Targets:**
- `validateEventStructure()`
- `validateNostrEvent()`
- `verifyNostrEventSignature()`

**Fuzzing Strategy:**
```javascript
// Generate malformed events
const fuzzers = [
  // Type confusion
  () => ({ id: 12345 }),
  () => ({ id: null }),
  () => ({ id: [] }),
  () => ({ id: {} }),

  // Boundary values
  () => ({ id: "" }),
  () => ({ id: "0".repeat(64) }),
  () => ({ id: "f".repeat(64) }),
  () => ({ id: "0".repeat(63) }),
  () => ({ id: "0".repeat(65) }),

  // Special characters
  () => ({ id: "\x00".repeat(64) }),
  () => ({ id: "café".repeat(16) }),

  // Nested objects
  () => ({ tags: [[[[[]]]]] }),
  () => ({ tags: Array(1000).fill(["a"]) }),

  // Large values
  () => ({ content: "x".repeat(10000000) }),
  () => ({ created_at: Number.MAX_SAFE_INTEGER }),
  () => ({ kind: -1 }),
];

for (const fuzzer of fuzzers) {
  try {
    await validateNostrEvent(fuzzer());
  } catch (e) {
    console.log("Crash found:", fuzzer.toString(), e);
  }
}
```

**Expected Result:** No crashes, all inputs handled gracefully.

---

### FUZZ-02: Encryption Fuzzing

**Objective:** Find issues in encryption/decryption handling.

**Fuzzing Targets:**
- `encryptData()`
- `decryptData()`

**Test Cases:**
```javascript
// Decrypt invalid data
const invalidCiphertexts = [
  new Uint8Array(0),           // Empty
  new Uint8Array(1),           // Too short
  new Uint8Array(16),          // Just auth tag
  crypto.getRandomValues(new Uint8Array(100)), // Random
];

for (const ct of invalidCiphertexts) {
  try {
    await decryptData(key, ct, validIV);
  } catch (e) {
    // Should throw, not crash
  }
}

// Encrypt edge cases
const edgeCases = [
  new ArrayBuffer(0),
  new ArrayBuffer(1),
  new ArrayBuffer(MAX_CONTENT_SIZE),
  new ArrayBuffer(MAX_CONTENT_SIZE + 1),
];
```

**Expected Result:** Clear error messages, no crashes.

---

### FUZZ-03: Base64 Handling Fuzzing

**Objective:** Test base64 encoding/decoding edge cases.

**Test Cases:**
```javascript
const invalidBase64 = [
  "",
  "!@#$%",
  "====",
  "A===",
  "AAAA====",
  "A".repeat(10000),
  "aGVsbG8\x00d29ybGQ=", // Embedded null
];

for (const input of invalidBase64) {
  try {
    base64ToArrayBuffer(input);
  } catch (e) {
    // Expected
  }
}
```

**Expected Result:** Invalid base64 rejected cleanly.

---

## Authentication Bypass Scenarios

### AUTH-01: Signature Skip Bypass

**Objective:** Verify signature validation cannot be bypassed.

**Scenario:**
1. Look for code paths that skip signature validation
2. Attempt to trigger skip conditions
3. Verify no bypass possible

**Code Review Points:**
```javascript
// Check for skipSignature option usage
validateNostrEvent(event, { skipSignature: true }); // Only in tests?

// Check for early returns before signature check
// Check for exception handling that might skip validation
```

**Expected Result:** No production bypass paths.

---

### AUTH-02: LEK Extraction

**Objective:** Verify LEK cannot be extracted from browser.

**Scenario:**
1. Access IndexedDB directly via DevTools
2. Attempt to export stored CryptoKeys
3. Look for LEK in memory dumps

**Test Steps:**
1. Open DevTools → Application → IndexedDB
2. Locate hypermark key storage
3. Attempt to read key values
4. Check if keys are extractable

**Expected Result:** Keys stored as non-extractable CryptoKey objects.

---

### AUTH-03: Pairing Token Reuse

**Objective:** Verify expired pairing tokens cannot be reused.

**Scenario:**
1. Generate pairing token
2. Wait for expiry (5 minutes)
3. Attempt to use expired token
4. Verify rejection

**Test Steps:**
```javascript
// Generate token
const token = generatePairingToken();

// Manually set timestamp to 6 minutes ago
token.timestamp = Date.now() - 6 * 60 * 1000;

// Attempt to use
const result = parsePairingToken(encodeToken(token));
console.assert(result.error === "Token expired", "Expired token accepted!");
```

**Expected Result:** Expired tokens rejected.

---

## Data Exfiltration Scenarios

### EXFIL-01: Memory Dump Analysis

**Objective:** Verify sensitive data properly cleared from memory.

**Scenario:**
1. Perform cryptographic operations
2. Trigger garbage collection
3. Analyze memory for key material

**Test Points:**
- Private key bytes after signing
- LEK bytes after derivation
- Decrypted plaintext after use

**Note:** JavaScript makes memory clearing difficult. Document limitations.

---

### EXFIL-02: Console/Log Leakage

**Objective:** Verify no sensitive data logged.

**Scenario:**
1. Enable verbose logging
2. Perform all operations
3. Search logs for sensitive data

**Search Patterns:**
- Private key hex strings (64 chars)
- LEK bytes
- Decrypted bookmark content
- Pairing codes

**Expected Result:** No sensitive data in logs.

---

### EXFIL-03: Error Message Information Disclosure

**Objective:** Verify error messages don't leak sensitive info.

**Scenario:**
1. Trigger various error conditions
2. Examine error messages
3. Verify no key material or internal state exposed

**Test Cases:**
```javascript
// Decryption with wrong key
try {
  await decryptData(wrongKey, ciphertext, iv);
} catch (e) {
  // Error should not contain key material
  console.assert(!e.message.includes(keyHex), "Key leaked in error!");
}

// Invalid signature
try {
  await verifyNostrEventSignature(invalidEvent);
} catch (e) {
  // Error should not reveal expected signature
}
```

**Expected Result:** Errors are informative but not revealing.

---

## Reporting Template

For each finding, use this template:

```
## Finding: [TITLE]

**Severity:** CRITICAL / HIGH / MEDIUM / LOW / INFO
**Category:** [Cryptography / Protocol / Network / Input Validation / Auth]
**Scenario:** [Reference to scenario ID]

### Description
[Detailed description of the vulnerability]

### Reproduction Steps
1. [Step 1]
2. [Step 2]
3. [Step 3]

### Impact
[What can an attacker do with this vulnerability]

### Affected Code
- File: `src/services/xxx.js`
- Function: `functionName()`
- Line: XXX

### Recommendation
[How to fix the vulnerability]

### Evidence
[Screenshots, logs, or code demonstrating the issue]
```

---

## Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2026-01-23 | Security Audit Prep | Initial scenarios |
